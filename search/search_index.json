{"config":{"lang":["en"],"separator":"[\\s\\-\\.\\_]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"XS Check","text":"<p>XS Check is a linter for AoE2:DE's flavour of XS. This website hosts the documentation for all the cool maths going into the checker</p>"},{"location":"code_gen/pa/","title":"Pseudo Assembly","text":"<p>This is the IR generated by the compiler for further compilation into byte code</p>"},{"location":"code_gen/pa/#1-pa-syntax","title":"1. PA Syntax","text":"<ol> <li>Addressed Instruction \\({\\tt li} \\rightarrow {\\tt l : i}\\)</li> <li>Addressed Instructions \\({\\tt lis} \\rightarrow {\\tt li}\\ |\\ {\\tt li\\ lis}\\)</li> <li>Address \\({\\tt l} \\rightarrow 1\\ |\\ 2\\ |\\ ...\\)</li> <li> <p>Instruction:</p> \\[{\\tt i} \\rightarrow \\quad {\\tt d} \\leftarrow {\\tt s}\\ |\\ {\\tt d} \\leftarrow {\\tt s\\ op\\ s}\\ | \\ {\\tt ret}\\ | \\ {\\tt ifn\\ s\\ goto\\ l}\\ |\\ {\\tt goto\\ l}\\ |\\ {\\tt push\\ s}\\ |\\ {\\tt pop\\ d}\\ |\\ {\\tt label}\\ |\\ {\\tt jmp\\ label}\\ |\\ {\\tt d \\leftarrow icast\\ s}\\ |\\ {\\tt d \\leftarrow fcast\\ s}\\ |\\ {\\tt d \\leftarrow scast\\ s}\\ |\\ {\\tt d \\leftarrow malloc\\ n}\\ |\\ {\\tt free\\ s}\\] </li> <li> <p>Operator:</p> \\[{\\tt op} \\rightarrow {\\tt +\\ |\\ -\\ |\\ *\\ |\\ /\\ |\\ \\%\\ |\\ &lt;\\ |\\ &gt;\\ |\\ &lt;=\\ |\\ &gt;=\\ |\\ ==\\ |\\ !=\\ |\\ \\&amp;\\&amp;\\ |\\ \\texttt{||}}\\] <ul> <li>Note: there are multiple variants of each operator for each type of input they support, denoted by a subscript: \\({\\tt op_i, op_f, op_b, op_s, op_v}\\) for \\({\\tt int}\\), \\({\\tt float}\\), \\({\\tt bool}\\), \\({\\tt string}\\), and \\({\\tt vector}\\) respectively. See \u00a7 2.5. Operations under Type Checking for details.</li> </ul> </li> <li> <p>Operand \\({\\tt d, s} \\rightarrow {\\tt c\\ |\\ r\\ |\\ v\\ |\\ mem[s]}\\)</p> </li> <li>Constant \\({\\tt c} \\rightarrow {\\tt LIT}\\)</li> <li>Register \\({\\tt r} \\rightarrow {\\tt r_i}\\)</li> <li>Identifier \\({\\tt v} \\rightarrow {\\tt x\\ |\\ y\\ |\\ ...}\\)</li> </ol> <p>Notes:</p> <ul> <li>\\({\\tt string}\\)s are implemented as a pointer to a memory address with a \\({\\tt u32}\\) length prefix followed by that many \\({\\tt u8}\\) values</li> <li>\\({\\tt vector}\\)s are implemented as a pointer to a memory address with three \\({\\tt f32}\\) values for \\(x\\), \\(y\\), and \\(z\\) respectively</li> </ul>"},{"location":"code_gen/pa/#2-pa-semantics-aliases","title":"2. PA Semantics &amp; aliases","text":"<ul> <li>PA assumes the availability of an infinite amount of identifiers (and memory) which are used like registers. Register allocation is deferred until bytecode generation.</li> <li>The availability of 32 enumerated 32-bit registers is assumed. The following aliases are used:</li> <li>\\({\\tt r_{ret} = r_0}\\): return value register</li> <li>\\({\\tt r_{sp} = r_{27}}\\): stack pointer</li> <li>\\({\\tt r_{bp} = r_{28}}\\): base pointer</li> <li>\\({\\tt r_{lp} = r_{29}}\\): link pointer</li> <li>\\({\\tt r_{xp} = r_{30}}\\): exception pointer</li> <li>The value of \\({\\tt r_{31}}\\) is read-only and always \\(0\\)</li> <li>\\({\\tt alloc\\ n}\\) is a mnemonic alias for \\({\\tt r_{sp} \\leftarrow r_{sp} + n}\\)</li> <li>\\({\\tt dealloc\\ n}\\) is a mnemonic alias for \\({\\tt r_{sp} \\leftarrow r_{sp} - n}\\)</li> <li>A stack is maintained to support procedures.</li> <li>A heap is maintained for dynamic memory allocation.</li> <li>The \\({\\tt goto}\\) instruction simply jumps to an address, whereas the \\({\\tt jmp}\\) instruction jumps to a label and writes the current address to \\({\\tt r_{lp}}\\)</li> <li>\\({\\tt ret}\\) jumps to the address in \\({\\tt r_{lp}} + 1\\)</li> </ul>"},{"location":"code_gen/xs_bc/","title":"Byte Code Generation","text":"<p>Generation of byte code from PA.</p>"},{"location":"code_gen/xs_mm/","title":"XS Maximal Munch (WIP)","text":"<p>Generation of PA from XS.</p>"},{"location":"code_gen/xs_mm/#1-notation","title":"1. Notation","text":"<ul> <li>\\(M_e(E) \\vdash ({\\tt d}, {\\tt lis})\\) is a function which yields the PA addressed instructions \\({\\tt lis}\\) which compute the value of the expression \\(E\\) and stores the result in \\({\\tt d}\\). An optional second argument may provide a custom name for \\({\\tt d}\\)</li> <li>\\(M_s(S) \\vdash {\\tt lis}\\) is a function which yields the PA addressed instructions \\({\\tt lis}\\) for statement \\(S\\)</li> <li>\\(\\Delta(X)\\) is a mapping of program variables to PA identifiers</li> <li>\\({\\tt newId} \\vdash {\\tt n}\\) is a generator which yields a new and unique identifier</li> <li>\\({\\tt newAddr} \\vdash {\\tt l}\\) is a generator which yields the next address for a PA instruction.</li> <li>\\({\\tt newAddr?} \\vdash {\\tt l}\\) is a function which peeks the next address for a PA instruction without incrementing it.</li> <li>\\({\\tt endAddr?} \\vdash {\\tt l}\\) is a function which yields the address of the returning/ending instruction name of the procedure/loop for which code is being generated.</li> <li> \\[\\begin{array}{rc}     {\\tt (xsMmCase)} &amp; \\begin{array}{c}         \\begin{array}{cc} C_1 &amp; C_2 \\end{array}         \\\\ \\hline         S_1     \\end{array} \\end{array}\\] <p>is read as \\(C_1 \\land C_2 \\implies S_1\\)</p> </li> </ul>"},{"location":"code_gen/xs_mm/#2-mm-for-expressions","title":"2. MM for Expressions","text":""},{"location":"code_gen/xs_mm/#21-pa-operand","title":"2.1. PA Operand","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmSrc)} &amp; M_e({\\tt s}) \\vdash ({\\tt s}, \\texttt{[]}) \\end{array} \\]"},{"location":"code_gen/xs_mm/#22-parenthesis","title":"2.2. Parenthesis","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmParen)} &amp; \\begin{array}{c}         M_e(E) \\vdash ({\\tt d}, {\\tt lis})         \\\\ \\hline         M_e((E)) \\vdash ({\\tt d}, {\\tt lis})     \\end{array} \\end{array} \\]"},{"location":"code_gen/xs_mm/#23-function-call-expression","title":"2.3. Function Call (Expression)","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmFncExpr)} &amp; \\begin{array}{c}         \\begin{array}{c}             \\Delta \\vdash {\\tt fnName} \\Downarrow (\\{{\\tt (id_1, L_1), ..., (id_n, L_n)}\\}, \\bar{S})             \\\\ M_e(E_i) \\vdash ({\\tt d_i}, {\\tt lis_i})             \\\\ M_e(L_{k}) \\vdash ({\\tt d_{k}}, {\\tt lis_{k}})             \\\\ {\\tt newAddr} \\vdash {\\tt l_i}             \\\\ {\\tt newAddr} \\vdash {\\tt l_{j}}             \\\\ {\\tt newAddr} \\vdash {\\tt l_{p}}             \\\\ {\\tt newAddr} \\vdash {\\tt l_r}         \\end{array}         \\\\ \\hline         M_e({\\tt fnName(E_1, ..., E_j)}) \\vdash \\left({\\tt r_{ret}}, \\begin{array}{c}             {\\tt lis_1\\ + ...\\ + lis_n}             \\\\ {\\tt +\\ [l_n : push\\ d_n, ..., l_1 : push\\ d_1]}             \\\\ {\\tt +\\ [l_j : jmp\\ fnName]}             \\\\ {\\tt +\\ [l_p : dealloc\\ n]}         \\end{array}\\right)     \\end{array} \\end{array} \\] <p>Note\\(^1\\): If the provided number of arguments \\(j\\) are less than the number of arguments that a function can accept \\(n\\), the remaining (\\(k \\in [j+1, n]\\)) parameters are filled by defaults at the call site itself. A function call with more than the acceptable number of parameters will never occur in a well-typed XS program</p> <p>Note\\(^2\\): calls to void functions cannot be used as expressions. A void function call in an expression will never occur in a well-typed XS program</p>"},{"location":"code_gen/xs_mm/#24-operations","title":"2.4. Operations","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmOp)} &amp; \\begin{array}{c}         \\begin{array}{c}             M_e(E_1) \\vdash ({\\tt d_1}, {\\tt lis_1})             \\\\ M_e(E_2) \\vdash ({\\tt d_2}, {\\tt lis_2})             \\\\ {\\tt newId} \\vdash {\\tt d_3}             \\\\ {\\tt newAddr} \\vdash {\\tt l}         \\end{array}         \\\\ \\hline         M_e(E_1\\ {\\tt op}\\ E_2) \\vdash ({\\tt d_3}, {\\tt lis_1\\ +\\ lis_2\\ +\\ } {\\tt [ l : d_3 \\leftarrow d_1\\ op\\ d_2 ]})     \\end{array} \\end{array} \\]"},{"location":"code_gen/xs_mm/#25-type-casting","title":"2.5. Type Casting","text":"<p>Whilst explicit type casting is not allowed in XS, when code is generated for an expression, there may be one additional step to perform an implicit type cast to the desired type for that expression. An invalid type cast will never be required in a well-typed XS program. This step is omitted from the description of the algorithm above since it would add unnecessary repetitive logic to each case and hinder clarity. In the actual algorithm, \\(M_e\\) takes an extra argument specifying the required type \\(T_{req}\\) and is provided with the inferred type \\(T_{inf}\\) from the type checking phase:</p> \\[ \\begin{array}{rc}     {\\tt (xsMmImplicitCast)} &amp; \\begin{array}{c}         \\begin{array}{c}             M_e(E) \\vdash ({\\tt d}, {\\tt lis})             \\\\ \\Gamma \\vdash E : T_{inf}             \\\\ T_{req} \\neq T_{inf}             \\\\ {\\tt newAddr} \\vdash {\\tt l}         \\end{array}         \\\\ \\hline         M_e(E, T_{req}) \\vdash ({\\tt d}, {\\tt lis\\ +\\ [ l : d \\leftarrow tcast\\ d ]})     \\end{array} \\end{array} \\] <p>Where \\({\\tt tcast}\\) may be one of \\({\\tt icast}\\), \\({\\tt fcast}\\), or \\({\\tt scast}\\) depending on \\(T_{req}\\).</p>"},{"location":"code_gen/xs_mm/#3-mm-for-statements","title":"3. MM for Statements","text":""},{"location":"code_gen/xs_mm/#31-sequence","title":"3.1. Sequence","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmSeq)} &amp; \\begin{array}{c}         \\begin{array}{c}             M_e(S) \\vdash {\\tt lis}             \\\\ M_e(\\bar{S}) \\vdash {\\tt lis'}         \\end{array}         \\\\ \\hline         M_s(S \\bar{S}) \\vdash {\\tt lis + lis'}     \\end{array} \\end{array} \\]"},{"location":"code_gen/xs_mm/#32-include","title":"3.2. Include","text":"<p>Include statements don't generate code themselves, they will be resolved like C macros before code generation</p>"},{"location":"code_gen/xs_mm/#33-var-def","title":"3.3. Var Def","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmDef)} &amp; \\begin{array}{c}         \\begin{array}{c}             \\\\ M_e(E) \\vdash {({\\tt d}, {\\tt lis})}         \\end{array}         \\\\ \\hline         \\begin{array}{cc}             M_s(T\\ X\\ =\\ E{\\tt ;}) \\vdash {\\tt lis} &amp; \\Delta \\oplus (X, {\\tt d})         \\end{array}     \\end{array} \\end{array} \\]"},{"location":"code_gen/xs_mm/#34-var-assign","title":"3.4. Var Assign","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmAssign)} &amp; \\begin{array}{c}         \\begin{array}{c}             \\Delta(X) \\vdash {\\tt d}             \\\\ M_e(E, \\Delta(X)) \\vdash {({\\tt d}, {\\tt lis})}         \\end{array}         \\\\ \\hline         \\begin{array}{cc}             M_s(X\\ =\\ E{\\tt ;}) \\vdash {\\tt lis}         \\end{array}     \\end{array} \\end{array} \\]"},{"location":"code_gen/xs_mm/#34-if-else","title":"3.4. If Else","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmIfElse)} &amp; \\begin{array}{c}         \\begin{array}{c}             M_e(E_c) \\vdash {({\\tt d_c}, {\\tt lis_c})}             \\\\ {\\tt newAddr} \\vdash {\\tt l_c}             \\\\ M_s(\\bar{S}_1) \\vdash {\\tt lis_1}             \\\\ \\color{yellow} {\\tt newAddr} \\vdash {\\tt l_{endThen}}             \\\\ {\\tt newAddr?} \\vdash {\\tt l_{else}}             \\\\ \\color{yellow} M_s(\\bar{S}_2) \\vdash {\\tt lis_2}             \\\\ \\color{yellow} {\\tt newAddr?} \\vdash {\\tt l_{endIf}}         \\end{array}         \\\\ \\hline         \\begin{array}{cc}             M_s({\\tt if\\ (} E_c {\\tt)\\ \\{\\ } \\bar{S_1} {\\tt\\ \\}\\ else\\ \\{\\ } \\bar{S_2} {\\tt\\ \\}}) \\vdash \\begin{array}{c}             {\\tt lis_c}             \\\\ {\\tt +\\ [l_c : ifn\\ d_c\\ goto\\ l_{else}}]             \\\\ {\\tt +\\ lis_1}             \\\\ \\color{yellow} {\\tt +\\ [l_{endThen} : goto\\ l_{endIf}}]             \\\\ \\color{yellow} {\\tt +\\ lis_2}         \\end{array}         \\end{array}     \\end{array} \\end{array} \\] <p>Note: The instructions highlighted in yellow are not generated when an else block is not present</p>"},{"location":"code_gen/xs_mm/#35-while","title":"3.5. While","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmWhile)} &amp; \\begin{array}{c}         \\begin{array}{c}             \\\\ {\\tt newAddr?} \\vdash {\\tt l_{eval}}             \\\\ M_e(E_c) \\vdash {({\\tt d_c}, {\\tt lis_c})}             \\\\ {\\tt newAddr} \\vdash {\\tt l_c}             \\\\ M_s(\\bar{S}) \\vdash {\\tt lis}             \\\\ {\\tt newAddr} \\vdash {\\tt l_{loop}}             \\\\ {\\tt newAddr?} \\vdash {\\tt l_{end}}         \\end{array}         \\\\ \\hline         \\begin{array}{cc}             M_s({\\tt while\\ (} E_c {\\tt)\\ \\{\\ } \\bar{S} {\\tt\\ \\}}) \\vdash \\begin{array}{c}             {\\tt lis_c}             \\\\ {\\tt +\\ [l_c : ifn\\ d_c\\ goto\\ l_{end}}]             \\\\ {\\tt +\\ lis}             \\\\ {\\tt +\\ [l_{loop} : goto\\ l_{eval}]}         \\end{array}         \\end{array}     \\end{array} \\end{array} \\]"},{"location":"code_gen/xs_mm/#36-for","title":"3.6. For","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmFor)} &amp; \\begin{array}{c}         \\begin{array}{c}             {\\tt \\ op} \\in \\{{\\tt &lt;, &lt;=, &gt;, &gt;=}\\}             \\\\ {\\tt \\#} \\in \\{{\\tt +, -}\\}             \\\\ \\Delta(X) \\vdash {\\tt d_1}             \\\\ M_e(E_1, \\Delta(X)) \\vdash {({\\tt d_1}, {\\tt lis_1})}             \\\\ \\color{aqua} {\\tt newAddr?} \\vdash {\\tt l_{eval}}             \\\\ \\color{aqua} M_e(E_2) \\vdash {({\\tt d_2}, {\\tt lis_2})}             \\\\ {\\tt newAddr} \\vdash {\\tt l_{cmp}}             \\\\ {\\tt newId} \\vdash {\\tt d_{cmp}}             \\\\ {\\tt newAddr} \\vdash {\\tt l_{br}}             \\\\ M_s(\\bar{S}) \\vdash {\\tt lis}             \\\\ {\\tt newAddr} \\vdash {\\tt l_{inc}}             \\\\ {\\tt newAddr} \\vdash {\\tt l_{loop}}             \\\\ {\\tt newAddr?} \\vdash {\\tt l_{end}}         \\end{array}         \\\\ \\hline         \\begin{array}{cc}             M_s({\\tt for\\ (}X\\ =\\ E_1{\\tt ;}\\ {\\tt op}\\ E_2 {\\tt)\\ \\{\\ } \\bar{S} {\\tt\\ \\}}) \\vdash \\begin{array}{c}             {\\tt lis_1\\ +\\ {\\color{aqua} lis_2}}             \\\\ {\\tt +\\ [l_{cmp} : d_{cmp} \\leftarrow d_1\\ op\\ d_2]}             \\\\ {\\tt +\\ [l_{br} : ifn\\ d_{cmp}\\ goto\\ l_{end}]}             \\\\ {\\tt +\\ lis}             \\\\ {\\tt +\\ [l_{inc} : d_1 \\leftarrow d_1\\ \\#\\ 1]}             \\\\ {\\tt +\\ [l_{loop} : goto\\ {\\color{aqua} l_{eval}}]}         \\end{array}         \\end{array}     \\end{array} \\end{array} \\]"},{"location":"code_gen/xs_mm/#37-switch","title":"3.7. Switch","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmSwitch)} &amp; \\begin{array}{c}         \\begin{array}{cccc}             &amp; M_e(E_c) \\vdash {({\\tt d_c}, {\\tt lis_c})} &amp;             \\\\ &amp; \\color{pink} M_e(E_i) \\vdash {({\\tt d_i}, {\\tt lis_{eval_i}})} &amp; \\color{pink} {\\tt newAddr} \\vdash {\\tt l_{cmp_i}} &amp; \\color{pink} {\\tt newAddr} \\vdash {\\tt l_{br_i}}             \\\\ &amp; {\\tt newAddr} \\vdash {\\tt l_{br_{default}}}             \\\\ \\color{aqua} {\\tt newAddr?} \\vdash {\\tt l_{start_i}} &amp; \\color{aqua} M_s(\\bar{S}_i) \\vdash {\\tt lis_i} &amp; {\\tt newAddr} \\vdash {\\tt l_{end_i}}             \\\\ {\\tt newAddr?} \\vdash {\\tt l_{default}} &amp; \\color{yellow} M_s(\\bar{S}_{d}) \\vdash {\\tt lis_{default}}             \\\\ &amp; {\\tt newAddr?} \\vdash {\\tt l_{end}}         \\end{array}         \\\\ \\hline         \\begin{array}{cc}             M_s({\\tt switch\\ (} E_c {\\tt)\\ \\{\\ } {\\tt case\\ } E_1 {\\tt\\ :\\ \\{\\ } \\bar{S_1} {\\tt\\ \\}} {\\tt\\ ...\\ case\\ } E_n {\\tt\\ :\\ \\{\\ } \\bar{S_n} {\\tt\\ \\}} {\\tt\\ default\\ :\\ \\{\\ } \\bar{S_d} {\\tt\\ \\}} {\\tt\\ \\}}) \\vdash \\begin{array}{c}             {\\tt lis_c}             \\\\ \\color{pink} {\\tt +\\ lis_{eval_1}}             \\\\ \\color{pink} {\\tt +\\ [l_{cmp_1} : d_{cmp_1} \\leftarrow d_c\\ !=\\ d_1]}             \\\\ \\color{pink} {\\tt +\\ [l_{br_1} : ifn\\ d_{cmp_1}\\ goto\\ {\\color{aqua} l_{start_1}}]}             \\\\ ...             \\\\ \\color{violet} {\\tt +\\ lis_{eval_n}}             \\\\ \\color{violet} {\\tt +\\ [l_{cmp_n} : d_{cmp_n} \\leftarrow d_c\\ !=\\ d_n]}             \\\\ \\color{violet} {\\tt +\\ [l_{br_n} : ifn\\ d_{cmp_n}\\ goto\\ {\\color{aqua} l_{start_n}}]}             \\\\ {\\tt +\\ [l_{br_{default}} : goto\\ l_{default}]}             \\\\ {\\tt {\\color{aqua} lis_1} + [l_{end_1} : goto\\ l_{end}]}             \\\\ ...             \\\\ {\\tt {\\color{aqua} lis_n} + [l_{end_n} : goto\\ l_{end}]}             \\\\ \\color{yellow} {\\tt +\\ lis_{default}}         \\end{array}         \\end{array}     \\end{array} \\end{array} \\] <p>Note\\(^1\\): The instructions highlighted in yellow are not generated when a default block is not present. In that case, \\({\\tt l_ {default}}\\) is the same label as \\({\\tt l_{end}}\\)</p> <p>Note\\(^2\\): The instructions highlighted in pink are repeated as a group</p>"},{"location":"code_gen/xs_mm/#38-break-return-continue-break-point-debug","title":"3.8 Break, Return, Continue, Break Point, Debug","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmBr)} &amp; \\begin{array}{c}         \\begin{array}{c}             {\\tt endAddr?} \\vdash {\\tt l_{end}}             \\\\ {\\tt newAddr} \\vdash {\\tt l_{br}}         \\end{array}         \\\\ \\hline         \\begin{array}{cc}             M_s({\\tt break;}) \\vdash {\\tt [l_{br} : goto\\ l_{end}]}         \\end{array}     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsMmCo)} &amp; \\begin{array}{c}         \\begin{array}{c}             {\\tt endAddr?} \\vdash {\\tt l_{end}}             \\\\ {\\tt newAddr} \\vdash {\\tt l_{co`}}         \\end{array}         \\\\ \\hline         \\begin{array}{cc}             M_s({\\tt continue;}) \\vdash {\\tt [l_{co} : goto\\ l_{end} - 1]}         \\end{array}     \\end{array} \\end{array} \\] <p>Note: \\({\\tt l_{end} - 1}\\) is the address of \\(l_{loop}\\) which goes to the start of the loop to evaluate the loop condition again.</p> \\[ \\begin{array}{rc}     {\\tt (xsMmRet)} &amp; \\begin{array}{c}         \\begin{array}{c}             M_e(E_r, {\\tt r_{ret}}) \\vdash {({\\tt r_{ret}}, {\\tt lis_r})}             \\\\ {\\tt endAddr?} \\vdash {\\tt l_{end}}             \\\\ {\\tt newAddr} \\vdash {\\tt l_{ret}}         \\end{array}         \\\\ \\hline         \\begin{array}{cc}             M_s({\\tt return\\ } {\\color{yellow}(E_r)} {\\tt ;}) \\vdash \\begin{array}{c}                 \\color{yellow} {\\tt lis_r}                 \\\\ {\\tt +\\ [l_{br} : goto\\ l_{end}]}         \\end{array}         \\end{array}     \\end{array} \\end{array} \\] <p>Note\\(^1\\): instructions highlighted in yellow are not generated for a void return.</p> <p>Note\\(^2\\): An \\({\\tt endAddr?}\\) call will yield the \\({\\tt l_{end}}\\) of the most recently entered for/while/switch/function body. It will never be invoked outside a proper context (outside a switch/for/while/function body) in a well-typed XS program</p> \\[ \\begin{array}{rc}     {\\tt (xsMmBrPt)} &amp; M_s({\\tt breakpoint;}) \\vdash {\\tt []} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsMmDbg)} &amp; M_s({\\tt dgb\\ id;}) \\vdash {\\tt []} \\end{array} \\] <p>Note: It is currently unknown what \\({\\tt breakpoint;}\\) and \\({\\tt dbg\\ id;}\\) do, however \\({\\tt breakpoint;}\\) seems to pause the XS Runtime in DE with no known way of resuming execution. These may be repurposed for an external debugger in the future.</p>"},{"location":"code_gen/xs_mm/#39-function-definition","title":"3.9. Function Definition","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmFnDef)} &amp; \\begin{array}{c}         \\begin{array}{c}             \\color{lime} {\\tt newAddr} \\vdash {\\tt l_{s_{lp}}}             \\\\ \\color{lime} {\\tt newAddr} \\vdash {\\tt l_{s_{bp}}}             \\\\ {\\tt newAddr} \\vdash {\\tt l_{m_{bp}}}             \\\\ \\color{aqua} {\\tt newAddr} \\vdash {\\tt l_{loca}}             \\\\ \\color{lime} {\\tt newAddr} \\vdash {\\tt l_{s_{r_i}}}             \\\\ \\color{magenta} {\\tt newAddr} \\vdash {\\tt l_{marg_i}}             \\\\ \\color{magenta} {\\tt newAddr} \\vdash {\\tt l_{larg_i}}             \\\\ M_s(\\bar{S}) \\vdash {\\tt lis}             \\\\ {\\tt newAddr?} \\vdash {\\tt l_{end}}             \\\\ \\color{red} {\\tt newAddr} \\vdash {\\tt l_{l_{r_i}}}             \\\\ \\color{orange} {\\tt newAddr} \\vdash {\\tt l_{locd}}             \\\\ \\color{red} {\\tt newAddr} \\vdash {\\tt l_{l_{bp}}}             \\\\ \\color{red} {\\tt newAddr} \\vdash {\\tt l_{l_{lp}}}             \\\\ {\\tt newAddr} \\vdash {\\tt l_{ret}}         \\end{array}         \\\\ \\hline         \\begin{array}{cc}             M_s({\\tt fnName(T_1\\ id_1\\ =\\ E_1,\\ ...,\\ T_n\\ id_n\\ =\\ E_n )\\ \\{\\ } \\bar{S} {\\tt\\ \\}}) \\vdash \\begin{array}{c}                 \\\\ \\color{lime} {\\tt [l_{s_{lp}} : push\\ r_{lp}]}                 \\\\ \\color{lime} {\\tt +\\ [l_{s_{bp}} : push\\ r_{bp}]}                 \\\\ {\\tt +\\ [l_{m_{bp}} : r_{bp} \\leftarrow r_{sp}]}                 \\\\ \\color{aqua} {\\tt +\\ [l_{loca} : alloc\\ k]}                 \\\\ \\color{lime} {\\tt +\\ [l_{s_{r_1}} : push\\ r_{1}]}                 \\\\ \\color{lime} {\\tt +\\ ...}                 \\\\ \\color{lime} {\\tt +\\ [l_{s_{r_{26}}} : push\\ r_{26}]}                 \\\\ \\color{magenta} {\\tt +\\ [l_{marg_i} : r_i \\leftarrow r_{bp} - (2 + i)]}                 \\\\ \\color{magenta} {\\tt +\\ [l_{larg_i} : r_i \\leftarrow mem[r_i]]}                 \\\\ {\\tt +\\ lis}                 \\\\ \\color{red} {\\tt +\\ [l_{l_{r_{26}}} : pop\\ r_{26}]}                 \\\\ \\color{red} {\\tt +\\ ...}                 \\\\ \\color{red} {\\tt +\\ [l_{l_{r_1}} : pop\\ r_{1}]}                 \\\\ \\color{orange} {\\tt +\\ [l_{locd} : dealloc\\ k]}                 \\\\ \\color{red} {\\tt +\\ [l_{l_{bp}} : pop\\ r_{bp}]}                 \\\\ \\color{red} {\\tt +\\ [l_{l_{lp}} : pop\\ r_{lp}]}                 \\\\ {\\tt +\\ [l_{r} : ret]}         \\end{array}         \\\\ \\Delta \\oplus ({\\tt fnName}, (\\{{\\tt (id_1, L_1), ..., (id_n, L_n)}\\}, \\bar{S}))         \\end{array}     \\end{array} \\end{array} \\] <p>Note\\(^1\\): \\({\\tt (2 + i)}\\) is a compile-time constant, only binary operations are allowed in the RHS of PA </p> <p>Note\\(^2\\): The instructions highlighted in green save the values of the registers to the stack so that they can be restored after the procedure finishes. The instructions highlighted in red restore these stored values before the procedure returns</p> <p>Note\\(^3\\): The instruction highlighted in teal allocates space for \\(k\\) local variables, and the instruction highlighted in orange deallocates this space.</p> <p>Note\\(^4\\): The instructions highlighted in purple load the parameters passed to the function in registers</p>"},{"location":"code_gen/xs_mm/#310-rule-definitions","title":"3.10. Rule Definitions","text":"<p>Same as \u00a7 3.9. Function Definition, except without the purple instructions since rules take no arguments</p>"},{"location":"code_gen/xs_mm/#311-postfix","title":"3.11. Postfix","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmPostfix)} &amp; \\begin{array}{c}     {\\tt newAddr} \\vdash {\\tt l_{pf}}     \\\\ {\\tt \\# \\in \\{+, -\\}}     \\\\ \\hline     \\\\ M_s({\\tt id\\#\\#;}) \\vdash {\\tt [l_{pf} : id\\ \\#\\ 1]}     \\end{array} \\end{array} \\]"},{"location":"code_gen/xs_mm/#312-label-goto","title":"3.12. Label, Goto","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmLabel)} &amp; \\begin{array}{c}     {\\tt newAddr} \\vdash {\\tt l_{lbl}}     \\\\ \\hline     \\\\ M_s({\\tt label\\ id;}) \\vdash {\\tt [l_{lbl} : id]}     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsMmGoto)} &amp; \\begin{array}{c}     {\\tt newAddr} \\vdash {\\tt l_{gto}}     \\\\ \\hline     \\\\ M_s({\\tt goto\\ id;}) \\vdash {\\tt [l_{gto} : goto\\ id]}     \\end{array} \\end{array} \\] <p>Note: An invalid \\({\\tt goto}\\) will not occur in a well-typed XS program.</p>"},{"location":"code_gen/xs_mm/#313-function-call-statement","title":"3.13. Function Call (Statement)","text":"<p>Same as \u00a7 2.3. Function Call (Expression)</p>"},{"location":"code_gen/xs_mm/#314-class-definition","title":"3.14. Class Definition","text":"\\[ \\begin{array}{rc}     {\\tt (xsMmClsDef)} &amp; M_s({\\tt class\\ clsName\\ \\{}\\ T_1\\ id_1\\ =\\ E_1;\\ ...\\ T_n\\ id_n\\ =\\ E_n; {\\tt\\ \\};}) \\vdash {\\tt []} \\end{array} \\] <p>Classes act purely as a type checking tool and do not generate any code. They cannot be used in XS anyway</p>"},{"location":"dynamic/xs_op_sem/","title":"XS Operational Semantics","text":"<p>This is a formal description of how a well typed XS program runs.</p>"},{"location":"dynamic/xs_op_sem/#1-notation","title":"1. Notation","text":"<ul> <li>\\(\\Delta\\) is a memory environment mapping XS identifiers to values</li> <li>\\(\\Delta \\vdash E_1 \\Downarrow E_2\\) means that \\(E_1\\) reduces to \\(E_2\\) in \\(\\Delta\\) (read as \\(\\Delta\\) yields \\(E_1\\) reduced to \\(E_2\\))</li> <li>\\((\\Delta, S) \\Downarrow \\Delta'\\) means that running statement \\(S\\) changes the memory environment to \\(\\Delta'\\). A reduction may optionally yield more statements/values along with the modified memory environment.</li> <li> \\[\\begin{array}{rc}     {\\tt (xsBssCase)} &amp; \\begin{array}{c}     \\begin{array}{cc} C_1 &amp; C_2 \\end{array}     \\\\ \\hline     S_1     \\end{array}     \\end{array}     \\] <p>is read as \\(C_1 \\land C_2 \\implies S_1\\)</p> </li> </ul>"},{"location":"dynamic/xs_op_sem/#2-big-step-semantics-for-expressions","title":"2. Big Step Semantics For Expressions","text":""},{"location":"dynamic/xs_op_sem/#21-literals","title":"2.1. Literals","text":"<p>let \\(L\\) denote a literal</p> \\[\\begin{matrix}{\\tt (xsBssLit)} &amp; \\Delta \\vdash L \\Downarrow L \\end{matrix}\\]"},{"location":"dynamic/xs_op_sem/#22-identifiers","title":"2.2. Identifiers","text":"<p>let \\(X\\) be an identifier</p> \\[\\begin{matrix}{\\tt (xsBssId)} &amp; \\Delta \\vdash X \\Downarrow \\Delta(X) \\end{matrix}\\]"},{"location":"dynamic/xs_op_sem/#23-parenthesis","title":"2.3. Parenthesis","text":"\\[ \\begin{array}{rc}     {\\tt (xsBssParen)} &amp; \\begin{array}{c}         \\Delta \\vdash E \\Downarrow L         \\\\ \\hline         \\Delta \\vdash (E) \\Downarrow L     \\end{array} \\end{array} \\]"},{"location":"dynamic/xs_op_sem/#24-function-call-expression","title":"2.4. Function Call (Expression)","text":"\\[ \\begin{array}{rc}     {\\tt (xsBssFncExpr)} &amp; \\begin{array}{c}         \\begin{array}{cccc}             \\Delta \\vdash {\\tt fnName} \\Downarrow (\\{{\\tt (id_1, L_1), ..., (id_n, L_n)}\\}, \\bar{S})             &amp; \\Delta \\vdash E_j \\Downarrow V_j             &amp; (\\Delta \\oplus ({\\tt id_1}, V_1) \\oplus ... \\oplus ({\\tt id_j}, V_j) \\oplus ... \\oplus ({\\tt id_n}, L_n), \\bar{S}) \\Downarrow (\\Delta', {\\tt return\\ (E_r)}; \\bar{S}')             &amp; \\Delta \\vdash E_r \\Downarrow L_r         \\end{array}         \\\\ \\hline         \\Delta \\vdash {\\tt fnName(E_1, ..., E_j)} \\Downarrow (\\Delta', L_r)     \\end{array} \\end{array} \\] <p>See \u00a7 3.9. Function Definition</p>"},{"location":"dynamic/xs_op_sem/#25-operations","title":"2.5. Operations","text":"\\[ \\begin{array}{rc}     {\\tt (xsBssOp)} &amp; \\begin{array}{c}         \\begin{array}{ccc}             \\Delta \\vdash E_1 \\Downarrow L_1             &amp; \\Delta \\vdash E_2 \\Downarrow L_2             &amp; \\Delta \\vdash L_1\\ {\\tt op}\\ L_2 \\Downarrow L_3         \\end{array}         \\\\ \\hline         \\Delta \\vdash E_1\\ {\\tt op}\\ E_2 \\Downarrow L_3     \\end{array} \\end{array} \\]"},{"location":"dynamic/xs_op_sem/#3-big-step-semantics-for-statements","title":"3. Big Step Semantics For Statements","text":""},{"location":"dynamic/xs_op_sem/#31-sequence","title":"3.1. Sequence","text":"\\[ \\begin{array}{rc}     {\\tt (xsBssSeq)} &amp; \\begin{array}{c}         \\begin{array}{cc}             (\\Delta, S) \\Downarrow \\Delta'             &amp; (\\Delta', \\bar{S}) \\Downarrow \\Delta''         \\end{array}         \\\\ \\hline         (\\Delta, S \\bar{S}) \\Downarrow \\Delta''     \\end{array} \\end{array} \\]"},{"location":"dynamic/xs_op_sem/#32-include","title":"3.2. Include","text":"<p>let \\(X\\) be a named, well typed XS program</p> \\[ \\begin{array}{rc}     {\\tt (xsBssInc)} &amp; \\begin{array}{c}         \\begin{array}{cc}             X := \\bar{S}             &amp; (\\{\\}, \\bar{S}) \\Downarrow \\Delta_X         \\end{array}         \\\\ \\hline         (\\Delta, {\\tt include}\\ X;) \\Downarrow \\Delta \\oplus \\Delta_X     \\end{array} \\end{array} \\]"},{"location":"dynamic/xs_op_sem/#33-var-defassign","title":"3.3. Var Def/Assign","text":"<p>let \\(X\\) be an identifier</p> \\[ \\begin{array}{rc}     {\\tt (xsBssAssign)} &amp; \\begin{array}{c}         \\begin{array}{c}             \\Delta \\vdash E \\Downarrow L         \\end{array}         \\\\ \\hline         (\\Delta, X\\ =\\ E;) \\Downarrow \\Delta \\oplus (X, L)     \\end{array} \\end{array} \\]"},{"location":"dynamic/xs_op_sem/#34-if-else","title":"3.4. If Else","text":"\\[ \\begin{array}{rc}     {\\tt (xsBssIfT)} &amp; \\begin{array}{c}         \\begin{array}{cc}             \\Delta \\vdash E_c \\Downarrow {\\tt true}             &amp; (\\Delta, S_1) \\Downarrow \\Delta_t         \\end{array}         \\\\ \\hline         (\\Delta, {\\tt if\\ (} E_c {\\tt)\\ \\{\\ } \\bar{S_1} {\\tt\\ \\}\\ else\\ \\{\\ } \\bar{S_2} {\\tt\\ \\}}) \\Downarrow \\Delta_t     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsBssIfF)} &amp; \\begin{array}{c}         \\begin{array}{cc}             \\Delta \\vdash E_c \\Downarrow {\\tt false}             &amp; (\\Delta, S_2) \\Downarrow \\Delta_f         \\end{array}         \\\\ \\hline         (\\Delta, {\\tt if\\ (} E_c {\\tt)\\ \\{\\ } \\bar{S_1} {\\tt\\ \\}\\ else\\ \\{\\ } \\bar{S_2} {\\tt\\ \\}}) \\Downarrow \\Delta_f     \\end{array} \\end{array} \\]"},{"location":"dynamic/xs_op_sem/#35-while","title":"3.5. While","text":"\\[ \\begin{array}{rc}     {\\tt (xsBssWhileT)} &amp; \\begin{array}{c}         \\begin{array}{cc}             \\Delta \\vdash E_c \\Downarrow {\\tt true}             &amp; (\\Delta, \\bar{S}; {\\tt while\\ (} E_c {\\tt)\\ \\{\\ } \\bar{S} {\\tt\\ \\}}) \\Downarrow \\Delta'         \\end{array}         \\\\ \\hline         (\\Delta, {\\tt while\\ (} E_c {\\tt)\\ \\{\\ } \\bar{S} {\\tt\\ \\}}) \\Downarrow \\Delta'     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsBssWhileTBr)} &amp; \\begin{array}{c}         \\begin{array}{cc}             \\Delta \\vdash E_c \\Downarrow {\\tt true}             &amp; (\\Delta, \\bar{S}) \\Downarrow (\\Delta', {\\tt break}; \\bar{S}')         \\end{array}         \\\\ \\hline         (\\Delta, {\\tt while\\ (} E_c {\\tt)\\ \\{\\ } \\bar{S} {\\tt\\ \\}}) \\Downarrow \\Delta'     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsBssWhileTCo)} &amp; \\begin{array}{c}         \\begin{array}{ccc}             \\Delta \\vdash E_c \\Downarrow {\\tt true}             &amp; (\\Delta, \\bar{S}) \\Downarrow (\\Delta', {\\tt coninue}; \\bar{S}')             &amp; (\\Delta', {\\tt while\\ (} E_c {\\tt)\\ \\{\\ } \\bar{S} {\\tt\\ \\}}) \\Downarrow \\Delta''         \\end{array}         \\\\ \\hline         (\\Delta, {\\tt while\\ (} E_c {\\tt)\\ \\{\\ } \\bar{S} {\\tt\\ \\}}) \\Downarrow \\Delta''     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsBssWhileF)} &amp; \\begin{array}{c}         \\begin{array}{cc}             \\Delta \\vdash E_c \\Downarrow {\\tt false}         \\end{array}         \\\\ \\hline         (\\Delta, {\\tt while\\ (} E_c {\\tt)\\ \\{\\ } \\bar{S} {\\tt\\ \\}}) \\Downarrow \\Delta     \\end{array} \\end{array} \\]"},{"location":"dynamic/xs_op_sem/#36-for","title":"3.6. For","text":"\\[ \\begin{array}{rc}     {\\tt (xsBssForInc)} &amp; \\begin{array}{c}         \\begin{array}{ccc}             \\Delta \\vdash E_1 \\Downarrow L_1             &amp; {\\tt op} \\in \\{{\\tt &lt;, &lt;=}\\}             &amp; (\\Delta \\oplus (X, L_1), {\\tt while\\ (} X {\\tt op}\\ E_2 {\\tt)\\ \\{\\ } \\bar{S}; {\\tt\\ X++; \\}}) \\Downarrow \\Delta'         \\end{array}         \\\\ \\hline         (\\Delta, {\\tt for\\ (}X\\ =\\ E_1{\\tt ;}\\ {\\tt op}\\ E_2 {\\tt)\\ \\{\\ } \\bar{S} {\\tt\\ \\}}) \\Downarrow \\Delta' \\ominus X     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsBssForDec)} &amp; \\begin{array}{c}         \\begin{array}{ccc}             \\Delta \\vdash E_1 \\Downarrow L_1             &amp; {\\tt op} \\in \\{{\\tt &gt;, &gt;=}\\}             &amp; (\\Delta \\oplus (X, L_1), {\\tt while\\ (} X {\\tt op}\\ E_2 {\\tt)\\ \\{\\ } \\bar{S}; {\\tt\\ X--; \\}}) \\Downarrow \\Delta'         \\end{array}         \\\\ \\hline         (\\Delta, {\\tt for\\ (}X\\ =\\ E_1{\\tt ;}\\ {\\tt op}\\ E_2 {\\tt)\\ \\{\\ } \\bar{S} {\\tt\\ \\}}) \\Downarrow \\Delta' \\ominus X     \\end{array} \\end{array} \\]"},{"location":"dynamic/xs_op_sem/#37-switch-case","title":"3.7. Switch Case","text":"\\[ \\begin{array}{rc}     {\\tt (xsBssSwitchC)} &amp; \\begin{array}{c}         \\begin{array}{cccc}             \\Delta \\vdash E_c \\Downarrow L_c             &amp; \\Delta \\vdash E_i \\Downarrow L_i             &amp; \\min\\limits_j L_j = L_c             &amp; (\\Delta, \\bar{S}_j) \\Downarrow \\Delta_j         \\end{array}         \\\\ \\hline         (\\Delta, {\\tt switch\\ (} E_c {\\tt)\\ \\{\\ } {\\tt case\\ } E_1 {\\tt\\ :\\ \\{\\ } \\bar{S_1} {\\tt\\ \\}} {\\tt\\ ...\\ case\\ } E_n {\\tt\\ :\\ \\{\\ } \\bar{S_n} {\\tt\\ \\}} {\\tt\\ default\\ :\\ \\{\\ } \\bar{S_d} {\\tt\\ \\}} {\\tt\\ \\}}) \\Downarrow \\Delta_j     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsBssSwitchD)} &amp; \\begin{array}{c}         \\begin{array}{cccc}             \\Delta \\vdash E_c \\Downarrow L_c             &amp; \\Delta \\vdash E_i \\Downarrow L_i             &amp; L_i \\ne L_c             &amp; (\\Delta, \\bar{S}_d) \\Downarrow \\Delta_d         \\end{array}         \\\\ \\hline         (\\Delta, {\\tt switch\\ (} E_c {\\tt)\\ \\{\\ } {\\tt case\\ } E_1 {\\tt\\ :\\ \\{\\ } \\bar{S_1} {\\tt\\ \\}} {\\tt\\ ...\\ case\\ } E_n {\\tt\\ :\\ \\{\\ } \\bar{S_n} {\\tt\\ \\}} {\\tt\\ default\\ :\\ \\{\\ } \\bar{S_d} {\\tt\\ \\}} {\\tt\\ \\}}) \\Downarrow \\Delta_d     \\end{array} \\end{array} \\]"},{"location":"dynamic/xs_op_sem/#38-break-continue-break-point-debug","title":"3.8 Break, Continue, Break Point, Debug","text":"\\[\\begin{matrix}{\\tt (xsBssBr)} &amp; (\\Delta, {\\tt break;}) \\Downarrow \\Delta \\end{matrix}\\] \\[\\begin{matrix}{\\tt (xsBssCo)} &amp; (\\Delta, {\\tt continue;}) \\Downarrow \\Delta \\end{matrix}\\] <p>Note: \\({\\tt break}\\) or \\({\\tt continue}\\) outside a looping construct is not allowed. \\({\\tt break}\\) may be used in switch case blocks but is unnecessary.</p> \\[\\begin{matrix}{\\tt (xsBssBrPt)} &amp; (\\Delta, {\\tt breakpoint;}) \\Downarrow \\Delta \\end{matrix}\\] \\[\\begin{matrix}{\\tt (xsBssBrPt)} &amp; (\\Delta, {\\tt dbg\\ id;}) \\Downarrow \\Delta \\end{matrix}\\] <p>Note: \\({\\tt breakpoint}\\) will pause XS execution with no known way of resumption. \\({\\tt debug}\\) operational semantics are unknown</p>"},{"location":"dynamic/xs_op_sem/#39-function-definition","title":"3.9. Function Definition","text":"\\[ \\begin{array}{rc}     {\\tt (xsBssFn)} &amp; \\begin{array}{c}         \\begin{array}{cccccc}             \\Delta \\vdash E_i \\Downarrow L_i         \\end{array}         \\\\ \\hline         (\\Delta, T_r\\ {\\tt fnName(T_1\\ id_1\\ =\\ E_1,\\ ...,\\ T_n\\ id_n\\ =\\ E_n )\\ \\{\\ } \\bar{S} {\\tt\\ \\}}) \\Downarrow \\Delta \\oplus ({\\tt fnName}, (\\{{\\tt (id_1, L_1), ..., (id_n, L_n)}\\}, \\bar{S}))     \\end{array} \\end{array} \\]"},{"location":"dynamic/xs_op_sem/#310-rule-definitions","title":"3.10. Rule Definitions","text":"\\[ \\begin{array}{rc}     {\\tt (xsBssRule)} &amp; (\\Delta, {\\tt rule\\ ruleName\\ ruleOpts\\ \\ \\{\\ } \\bar{S} {\\tt\\ \\}}) \\Downarrow \\Delta \\oplus ({\\tt ruleName}, \\bar{S}) \\end{array} \\] <p>Note: Running a rule has the same semantics as a void function with no arguments.</p>"},{"location":"dynamic/xs_op_sem/#311-postfix","title":"3.11. Postfix","text":"\\[ \\begin{array}{rc}     {\\tt (xsBssPostInc)} &amp; (\\Delta, X{\\tt ++};) \\Downarrow \\Delta \\oplus (X, \\Delta(X) + 1) \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsBssPostDec)} &amp; (\\Delta, X{\\tt --};) \\Downarrow \\Delta \\oplus (X, \\Delta(X) - 1) \\end{array} \\]"},{"location":"dynamic/xs_op_sem/#312-label-goto","title":"3.12. Label, Goto","text":"\\[ \\begin{array}{rc}     {\\tt (xsBssLabel)} &amp; \\begin{array}{c}         \\begin{array}{cc}             (\\Delta, \\bar{S}) \\Downarrow \\Delta'         \\end{array}         \\\\ \\hline         (\\Delta, {\\tt label\\ id}; \\bar{S}) \\Downarrow \\Delta'     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsBssGoto)} &amp; \\begin{array}{c}         \\begin{array}{cc}             (\\Delta, \\bar{S}) \\Downarrow (\\Delta', {\\tt goto\\ id}; \\bar{S}')             &amp; (\\Delta', {\\tt label\\ id}; \\bar{S}) \\Downarrow \\Delta''         \\end{array}         \\\\ \\hline         (\\Delta, {\\tt label\\ id}; \\bar{S}) \\Downarrow \\Delta''     \\end{array} \\end{array} \\]"},{"location":"dynamic/xs_op_sem/#313-function-call-statement","title":"3.13. Function Call (Statement)","text":"<p>\\(({\\tt xsBssFncStmt})\\) same as 2.4. Function Call (Expression) with a terminating semicolon.</p>"},{"location":"dynamic/xs_op_sem/#314-class-definition","title":"3.14. Class Definition","text":"\\[ \\begin{array}{rc}     {\\tt (xsBssClsDef)} &amp; \\begin{array}{c}         \\begin{array}{c}             \\Delta \\vdash E_i \\Downarrow L_i         \\end{array}         \\\\ \\hline         (\\Delta, {\\tt class\\ clsName\\ \\{}\\ T_1\\ id_1\\ =\\ E_1;\\ ...\\ T_n\\ id_n\\ =\\ E_n; {\\tt\\ \\};}) \\Downarrow \\Delta \\oplus ({\\tt clsName}, \\{ ({\\tt id_1}, L_1), ..., ({\\tt id_n}, L_n) \\})     \\end{array} \\end{array} \\] <p>Classes are unused in XS and can't be instantiated afaik. This exists purely for completeness' sake.</p>"},{"location":"parsing/xs_grammar/","title":"XS Grammar","text":"<p>Syntax for production rules is:</p> <p>\\(A \\to B\\alpha\\)</p> <p>The following represent non terminal symbols: - uppercase letters</p> <p>The following represent terminal symbols: - lowercase words/letters - greek symbols - keywords</p>"},{"location":"parsing/xs_grammar/#1-program","title":"1. Program","text":""},{"location":"parsing/xs_grammar/#11-literals","title":"1.1. Literals","text":"<p>\\(\\text{NUM} \\rightarrow \\text{INT | FLT}\\)</p> <p>\\(\\text{VCT} \\rightarrow \\texttt{vector(}\\text{NUM}\\texttt{, }\\text{NUM}\\texttt{, }\\text{NUM}\\texttt{)}\\)</p>"},{"location":"parsing/xs_grammar/#12-top-level-statements","title":"1.2. Top Level Statements","text":"<p>\\(\\text{X} \\rightarrow \\text{I X | P}\\)</p> <p>\\(\\text{P} \\rightarrow \\text{RL P | FN P | V}_\\text{top}\\text{ P | }\\epsilon\\)</p> <p>where</p> <p>\\(\\color{gray} \\text{X} := \\text{XS script}\\)</p> <p>\\(\\color{gray} \\text{I} := \\text{Include statement}\\)</p> <p>\\(\\color{gray} \\text{P} := \\text{Program}\\)</p> <p>\\(\\color{gray} \\text{RL} := \\text{Rule def}\\)</p> <p>\\(\\color{gray} \\text{FN} := \\text{Function def}\\)</p> <p>\\(\\color{gray} \\text{V}_\\text{top} := \\text{Top level variable definition}\\)</p>"},{"location":"parsing/xs_grammar/#13-prelude","title":"1.3. Prelude","text":"<p>This consists of all the constants and functions described in</p> <ol> <li>XS Constant Reference</li> <li>XS Function Reference</li> </ol>"},{"location":"parsing/xs_grammar/#2-statement","title":"2. Statement","text":"<p>\\(\\text{S} \\rightarrow \\text{V}_\\text{decl}\\text{ | V}_\\text{def}\\text{ | V}_\\text{asgn}\\text{ | IE | W | F | SC | R | BR | CO | LBL | GT | DBG | BRPT | DP | DM}\\)</p> <p>\\(\\bar{\\text{S}} \\rightarrow \\text{S }\\bar{\\text{S}}\\text{ | }\\epsilon\\)</p> <p>\\(\\text{B} \\rightarrow \\texttt{\\{}\\bar{\\text{ S }}\\texttt{\\}}\\)</p> <p>\\(\\text{BS} \\rightarrow \\text{B | S}\\)</p> <p>where</p> <p>\\(\\color{gray} \\text{S} := \\text{Statement}\\)</p> <p>\\(\\color{gray} \\bar{\\text{S}} := \\text{Statements}\\)</p> <p>\\(\\color{gray} \\text{B} := \\text{Body}\\)</p> <p>\\(\\color{gray} \\text{BS} := \\text{Body or statement}\\)</p> <p>\\(\\color{gray} \\text{V}_\\text{decl} := \\text{Variable declaration}\\)</p> <p>\\(\\color{gray} \\text{V}_\\text{def} := \\text{Variable definition}\\)</p> <p>\\(\\color{gray} \\text{V}_\\text{asgn} := \\text{Variable Assignment}\\)</p> <p>\\(\\color{gray} \\text{IE} := \\text{If (Else) statement}\\)</p> <p>\\(\\color{gray} \\text{W} := \\text{While loop}\\)</p> <p>\\(\\color{gray} \\text{F} := \\text{For loop}\\)</p> <p>\\(\\color{gray} \\text{SC} := \\text{Switch case}\\)</p> <p>\\(\\color{gray} \\text{R} := \\text{Return statement}\\)</p> <p>\\(\\color{gray} \\text{BR} := \\text{Break statement}\\)</p> <p>\\(\\color{gray} \\text{CO} := \\text{Continue statement}\\)</p> <p>\\(\\color{gray} \\text{BRPT} := \\text{Breakpoint}\\)</p>"},{"location":"parsing/xs_grammar/#21-top-level-var-def","title":"2.1. Top Level Var Def","text":"<p>\\(\\text{V}_\\text{top} \\rightarrow \\texttt{extern } \\text{V}_\\text{top}\\text{ | }\\texttt{const }\\text{V}_\\text{top}\\text{ | }\\texttt{static }\\text{V}_\\text{top}\\)</p> <p>\\(\\text{V}_\\text{top} \\rightarrow \\text{DTYPE ID}\\texttt{ = }\\text{LIT}\\texttt{;}\\)</p> <p>\\(\\text{DTYPE} \\rightarrow \\texttt{int | float | bool | string | vect}\\)</p> <p>\\(\\text{LIT} \\rightarrow \\text{INT | FLT | STR | VCT | BOOL}\\)</p> <p>Note: XS currently has bugs with defining top level strings and vectors</p> <p>where</p> <p>\\(\\color{gray}\\text{DTYPE} := \\text{Datatype}\\)</p> <p>\\(\\color{gray}\\text{ID} := \\text{Identifier}\\)</p> <p>\\(\\color{gray}\\text{LIT} := \\text{Literal}\\)</p>"},{"location":"parsing/xs_grammar/#22-var-decl","title":"2.2. Var Decl","text":"<p>\\(\\text{V}_\\text{decl} \\rightarrow \\texttt{static }\\text{V}_\\text{decl}\\)</p> <p>\\(\\text{V}_\\text{decl} \\rightarrow \\text{DTYPE ID}\\texttt{;}\\)</p>"},{"location":"parsing/xs_grammar/#23-var-def","title":"2.3. Var Def","text":"<p>\\(\\text{V}_\\text{def} \\rightarrow \\texttt{const }\\text{V}_\\text{def}\\)</p> <p>\\(\\text{V}_\\text{def} \\rightarrow \\text{DTYPE ID}\\texttt{ = }\\text{E}\\texttt{;}\\)</p>"},{"location":"parsing/xs_grammar/#24-var-assign","title":"2.4. Var Assign","text":"<p>\\(\\text{V}_\\text{asgn} \\rightarrow \\text{ID}\\texttt{ = }\\text{E}\\texttt{;}\\)</p> <p>where</p> <p>\\(\\color{gray}\\text{E} := \\text{Expression}\\)</p>"},{"location":"parsing/xs_grammar/#25-if-else","title":"2.5. If Else","text":"<p>\\(\\text{IE} \\rightarrow \\texttt{if ( }\\text{E}\\texttt{ ) }\\text{BS ELSE}\\)</p> <p>\\(\\text{ELSE} \\rightarrow \\texttt{else }\\text{BS | } \\epsilon\\)</p> <p>where</p> <p>\\(\\color{gray}\\text{ELSE} := \\text{Else branch}\\)</p>"},{"location":"parsing/xs_grammar/#26-while","title":"2.6. While","text":"<p>\\(\\text{W} \\rightarrow \\texttt{while ( }\\text{E}\\texttt{ ) }\\text{BS}\\)</p>"},{"location":"parsing/xs_grammar/#27-for","title":"2.7. For","text":"<p>\\(\\text{F} \\rightarrow \\texttt{for ( }\\text{V}_\\text{asgn} \\text{ OP}_\\text{rel} \\text{ INT} \\texttt{ ) }\\text{BS}\\)</p> <p>where</p> <p>\\(\\color{gray}\\text{OP}_\\text{rel} := \\text{Relational operators}\\)</p>"},{"location":"parsing/xs_grammar/#28-switch","title":"2.8. Switch","text":"<p>\\(\\text{SC} \\rightarrow \\texttt{switch ( E ) \\{ } \\text{CASES} \\texttt{ \\}}\\)</p> <p>\\(\\text{CASES} \\rightarrow \\text{CASE CASES | DEFAULT CASES}_\\text{no default}\\text{ | } \\epsilon\\)</p> <p>\\(\\text{CASES}_\\text{no default} \\rightarrow \\text{CASE CASES}_\\text{no default}\\text{ | } \\epsilon\\)</p> <p>\\(\\text{CASE} \\rightarrow \\texttt{case} \\text{ LIT } \\texttt{:} \\text{ B}\\)</p> <p>\\(\\text{DEFAULT} \\rightarrow \\texttt{default :} \\text{ B}\\)</p> <p>where</p> <p>\\(\\color{gray}\\text{CASES} := \\text{Optional case statements with one optional default case}\\)</p> <p>\\(\\color{gray}\\text{CASES}_\\text{no default} := \\text{Optional case statements only}\\)</p> <p>\\(\\color{gray}\\text{CASE} := \\text{case statement}\\)</p> <p>\\(\\color{gray}\\text{DEFAULT} := \\text{default statement}\\)</p>"},{"location":"parsing/xs_grammar/#29-functions","title":"2.9. Functions","text":"<p>\\(\\text{FN} \\rightarrow \\texttt{extern}\\text{ FN | }\\texttt{mutable}\\text{ FN}\\)</p> <p>\\(\\text{FN} \\rightarrow \\text{RTYPE ID ( ARGS}_\\text{formal}{ ) } \\text{B}\\)</p> <p>\\(\\text{RTYPE} \\rightarrow \\texttt{void}\\text{ | DTYPE}\\)</p> <p>\\(\\text{ARGS}_\\text{formal} \\rightarrow \\text{ARG | ARG, ARGS}_\\text{formal}\\)</p> <p>\\(\\text{ARG} \\rightarrow\\text{DTYPE ID = LIT | } \\epsilon\\)</p> <p>where</p> <p>\\(\\color{gray}\\text{RTYPE} := \\text{Return type}\\)</p> <p>\\(\\color{gray}\\text{ARGS}_\\text{formal} := \\text{Formal Arguments}\\)</p> <p>\\(\\color{gray}\\text{ARG} := \\text{Argument}\\)</p>"},{"location":"parsing/xs_grammar/#210-return","title":"2.10. Return","text":"<p>\\(\\text{R} \\rightarrow\\texttt{return ( } \\text{E} \\texttt{ );}\\)</p> <p>\\(\\text{R} \\rightarrow\\texttt{return;}\\)</p>"},{"location":"parsing/xs_grammar/#211-rules","title":"2.11. Rules","text":"<p>\\(\\text{RL} \\rightarrow \\texttt{rule}\\text{ ID RPS B}\\)</p> <p>\\(\\text{RPS} \\rightarrow \\text{RP RPS | } \\epsilon\\)</p> <p>\\(\\text{RP} \\rightarrow \\text{RP}_\\text{act} \\text{ | } \\text{RP}_\\text{grp} \\text{ | } \\text{RP}_\\text{sfq} \\text{ | } \\text{RP}_\\text{xfq} \\text{ | } \\text{RP}_\\text{rim} \\text{ | } \\text{RP}_\\text{pty}\\)</p> <p>\\(\\text{RP}_\\text{act} \\rightarrow \\texttt{active | inactive}\\)</p> <p>\\(\\text{RP}_\\text{grp} \\rightarrow \\texttt{group} \\text{ ID}\\)</p> <p>\\(\\text{RP}_\\text{sfq} \\rightarrow \\texttt{minInterval} \\text{ INT | }\\texttt{highFrequency}\\)</p> <p>\\(\\text{RP}_\\text{xfq} \\rightarrow \\texttt{maxInterval} \\text{ INT}\\)</p> <p>\\(\\text{RP}_\\text{rim} \\rightarrow \\texttt{runImmediately}\\)</p> <p>\\(\\text{RP}_\\text{pty} \\rightarrow \\texttt{priority} \\text{ INT}\\)</p> <p>Note: only one of each parameter can be present in a rule def, this needs to be a linting time check, unfortunately its not possible to bake it into the grammar</p> <p>\\(\\color{gray}\\text{RPS} := \\text{Rule parameters}\\)</p> <p>\\(\\color{gray}\\text{RP} := \\text{Rule parameter}\\)</p> <p>\\(\\color{gray}\\text{RP}_\\text{act} := \\text{Active state}\\)</p> <p>\\(\\color{gray}\\text{RP}_\\text{grp} := \\text{Group}\\)</p> <p>\\(\\color{gray}\\text{RP}_\\text{sfq} := \\text{Min frequency}\\)</p> <p>\\(\\color{gray}\\text{RP}_\\text{xfq} := \\text{Max frequency}\\)</p> <p>\\(\\color{gray}\\text{RP}_\\text{rim} := \\text{Run Immediately}\\)</p> <p>\\(\\color{gray}\\text{RP}_\\text{pty} := \\text{Priority}\\)</p>"},{"location":"parsing/xs_grammar/#212-postfix","title":"2.12. Postfix","text":"<p>\\(\\text{DP} \\rightarrow \\text{ID}\\texttt{++}\\)</p> <p>\\(\\text{DM} \\rightarrow \\text{ID}\\texttt{--}\\)</p>"},{"location":"parsing/xs_grammar/#213-include","title":"2.13. Include","text":"<p>\\(\\text{I} \\rightarrow \\texttt{include }\\text{STR}\\texttt{;}\\)</p>"},{"location":"parsing/xs_grammar/#214-break","title":"2.14. Break","text":"<p>\\(\\text{BR} \\rightarrow \\texttt{break;}\\)</p>"},{"location":"parsing/xs_grammar/#215-continue","title":"2.15. Continue","text":"<p>\\(\\text{CO} \\rightarrow \\texttt{continue;}\\)</p>"},{"location":"parsing/xs_grammar/#216-label-def","title":"2.16. Label Def","text":"<p>\\(\\text{LBL} \\rightarrow \\texttt{label }\\text{ID}\\texttt{;}\\)</p>"},{"location":"parsing/xs_grammar/#217-goto","title":"2.17. Goto","text":"<p>\\(\\text{GT} \\rightarrow \\texttt{goto }\\text{ID}\\texttt{;}\\)</p>"},{"location":"parsing/xs_grammar/#218-function-call-statement","title":"2.18. Function Call (Statement)","text":"<p>\\(\\text{FNCS} \\rightarrow \\text{FNC}\\texttt{;}\\)</p>"},{"location":"parsing/xs_grammar/#219-debug","title":"2.19. Debug","text":"<p>\\(\\text{DBG} \\rightarrow \\texttt{dbg }\\text{ID}\\texttt{;}\\)</p> <p>Note: I don't know what this does in XS, its valid syntax though.</p>"},{"location":"parsing/xs_grammar/#220-breakpoint","title":"2.20. Breakpoint","text":"<p>\\(\\text{BRPT} \\rightarrow \\texttt{breakpoint;}\\)</p> <p>Note: This will pause XS execution. I don't know if its possible to resume execution/if this keyword is useful.</p>"},{"location":"parsing/xs_grammar/#221-class","title":"2.21. Class","text":"<p>\\(\\text{CLS} \\rightarrow \\texttt{class } \\text{ID} \\texttt{ \\{ } \\text{MEM\\_VARS} \\texttt{ \\};}\\)</p> <p>\\(\\text{MEM\\_VARS} \\rightarrow \\text{DTYPE ID}\\texttt{ = }\\text{E}\\texttt{;} \\text{ MEM\\_VARS | } \\epsilon\\)</p> <p>Note: I don't know how to use classes in XS, its valid syntax though. The furthest I've gotten is declaring a class variable: \\({\\tt ClsName obj;}\\). Initialising it or accessing member values doesn't seem possible.</p>"},{"location":"parsing/xs_grammar/#222-docstring","title":"2.22. Docstring","text":""},{"location":"parsing/xs_grammar/#todo","title":"Todo","text":""},{"location":"parsing/xs_grammar/#3-expression","title":"3. Expression","text":"<p>\\(\\text{E7} \\rightarrow \\text{LIT | ID | P | FNC}\\)</p> <p>\\(\\text{E6} \\rightarrow \\text{E7 | E6 }\\texttt{*}\\text{ E7 | E6 }\\texttt{/}\\text{ E7 | E6 }\\texttt{\\%}\\text{ E7}\\)</p> <p>\\(\\text{E5} \\rightarrow \\text{E6 | E5 }\\texttt{+}\\text{ E6 | E5 }\\texttt{-}\\text{ E6}\\)</p> <p>\\(\\text{E4} \\rightarrow \\text{E5 | E4 }\\texttt{&lt;}\\text{ E5 | E4 }\\texttt{&gt;}\\text{ E5 | E4 }\\texttt{&gt;=}\\text{ E5 | E4 }\\texttt{&lt;=}\\text{ E5}\\)</p> <p>\\(\\text{E3} \\rightarrow \\text{E4 | E3 }\\texttt{==}\\text{ E4 | E3 }\\texttt{!=}\\text{ E4}\\)</p> <p>\\(\\text{E2} \\rightarrow \\text{E3 | E2 }\\texttt{&amp;&amp;}\\text{ E3}\\)</p> <p>\\(\\text{E1} \\rightarrow \\text{E2 | E1 }\\texttt{||}\\text{ E2}\\)</p> <p>\\(\\text{E} \\rightarrow \\text{E1}\\)</p>"},{"location":"parsing/xs_grammar/#31-parenthesis","title":"3.1. Parenthesis","text":"<p>\\(\\text{P} \\rightarrow \\text{(E)}\\)</p>"},{"location":"parsing/xs_grammar/#32-function-call-expression","title":"3.2. Function Call (Expression)","text":"<p>\\(\\text{FNC} \\rightarrow \\text{ID(ARGS}_\\text{actual}\\text{)}\\)</p> <p>\\(\\text{ARGS}_\\text{actual} \\rightarrow \\text{ARGS}' \\text{ | } \\epsilon\\)</p> <p>\\(\\text{ARGS}' \\rightarrow \\text{E | E, ARGS}'\\)</p> <p>where</p> <p>\\(\\color{gray}\\text{ARGS}_\\text{actual} := \\text{Actual Arguments}\\)</p>"},{"location":"parsing/xs_grammar/#4-the-full-grammar","title":"4. The Full Grammar","text":""},{"location":"parsing/xs_keywords/","title":"XS Keywords","text":"<pre><code>vector\ninclude\nswitch\ncase\nwhile\nbreak\ndefault\nrule\nif\nthen\nelse\ngoto\nlabel\nfor\ndbg\nreturn\nvoid\nint\nbool\nfloat\nstring\nconst\npriority\nminInterval\nmaxInterval\nhighFrequency\nactive\ninactive\ngroup\ninfiniteLoopLimit\ninfiniteRecursionLimit\nbreakpoint\nstatic\ncontinue\nextern\nexport\nrunImmediately\nmutable\nclass\n</code></pre>"},{"location":"parsing/xs_tokens/","title":"XS Tokens","text":"<p>The following is a list of XS tokens</p>"},{"location":"parsing/xs_tokens/#1-operators","title":"1. Operators","text":""},{"location":"parsing/xs_tokens/#11-arithmetic-operators","title":"1.1. Arithmetic Operators","text":"<p>\\(\\text{PLUS} :=\\ \\texttt{+}\\)</p> <p>\\(\\text{MINUS} :=\\ \\texttt{-}\\)</p> <p>\\(\\text{STAR} :=\\ \\texttt{*}\\)</p> <p>\\(\\text{FSLASH} :=\\ \\texttt{/}\\)</p> <p>\\(\\text{PCENT} :=\\ \\texttt{\\%}\\)</p>"},{"location":"parsing/xs_tokens/#12-prefixpostfix-operators","title":"1.2. Prefix/Postfix Operators","text":"<p>\\(\\text{DPLUS} :=\\ \\texttt{++}\\)</p> <p>\\(\\text{DMINUS} :=\\ \\texttt{--}\\)</p>"},{"location":"parsing/xs_tokens/#13-relational-operators","title":"1.3. Relational Operators","text":"<p>\\(\\text{LT} :=\\ \\texttt{&lt;}\\)</p> <p>\\(\\text{GT} :=\\ \\texttt{&gt;}\\)</p> <p>\\(\\text{LE} :=\\ \\texttt{&lt;=}\\)</p> <p>\\(\\text{GE} :=\\ \\texttt{&gt;=}\\)</p> <p>\\(\\text{DEQ} :=\\ \\texttt{==}\\)</p> <p>\\(\\text{NEQ} :=\\ \\texttt{!=}\\)</p>"},{"location":"parsing/xs_tokens/#14-boolean-operators","title":"1.4. Boolean Operators","text":"<p>\\(\\text{AND} :=\\ \\texttt{\\&amp;\\&amp;}\\)</p> <p>\\(\\text{OR} :=\\ \\texttt{||}\\)</p>"},{"location":"parsing/xs_tokens/#2-punctuations","title":"2. Punctuations","text":"<p>\\(\\text{EQ} :=\\ \\texttt{=}\\)</p> <p>\\(\\text{LBRACE} :=\\ \\texttt{\\{}\\)</p> <p>\\(\\text{RBRACE} :=\\ \\texttt{\\}}\\)</p> <p>\\(\\text{LPAREN} :=\\ \\texttt{(}\\)</p> <p>\\(\\text{RPAREN} :=\\ \\texttt{)}\\)</p> <p>\\(\\text{SEMICOLON} :=\\ \\texttt{;}\\)</p> <p>\\(\\text{COLON} :=\\ \\texttt{:}\\)</p> <p>\\(\\text{COMMA} :=\\ \\texttt{,}\\)</p> <p>\\(\\text{DOT} :=\\ \\texttt{.}\\)</p>"},{"location":"parsing/xs_tokens/#3-literals","title":"3. Literals","text":"<p>\\(\\text{INT} :=\\ \\texttt{-999999999} \\text{ to } \\texttt{999999999}\\)</p> <p>\\(\\text{FLT} :=\\ \\texttt{-?\\d+.\\d+} \\text{ where } \\texttt{\\d} \\text{ is a digit}\\)</p> <p>\\(\\text{STR} :=\\ \\texttt{\"\\w*\"}  \\text{ where } \\texttt{\\w} \\text{ is a unicode character}\\)</p> <p>\\(\\text{BOOL} :=\\ \\texttt{false} \\text{ or } \\texttt{true}\\)</p> <p>\\(\\text{ID} :=\\ \\texttt{[a-zA-Z\\_][a-zA-Z\\_0-9]*}\\)</p> <p>Note: Vectors are part of the grammar and are not treated as literals</p>"},{"location":"parsing/xs_tokens/#4-comments","title":"4. Comments","text":""},{"location":"parsing/xs_tokens/#41-single-comment","title":"4.1. Single Comment","text":"<p>\\(\\text{CMT} := \\texttt{//[\\^ \\\\ n]*}\\)</p>"},{"location":"parsing/xs_tokens/#42-multiple-line-comment","title":"4.2. Multiple Line Comment","text":"<p>\\(\\text{CMT} := /* .* */\\)</p>"},{"location":"parsing/xs_tokens/#xs-keywords","title":"XS Keywords","text":"<p>every XS keyword is a token</p> <p>XS Keywords</p>"},{"location":"static/xs_liveness/","title":"XS Liveness Analysis","text":""},{"location":"static/xs_sign/","title":"XS Sign Analysis","text":""},{"location":"static/xs_type_chk/","title":"XS Type Checking","text":""},{"location":"static/xs_type_chk/#1-notation","title":"1. Notation","text":"<ul> <li>\\(\\Gamma\\) is a type environment mapping XS identifiers to types.</li> <li>\\(\\Gamma \\vdash E : T\\) means that an expression \\(E\\) has type \\(T\\) in \\(\\Gamma\\) (read as \\(\\Gamma\\) yields \\(E\\) of type \\(T\\))</li> <li>\\(\\Gamma \\vdash S\\) means that a statement \\(S\\) is soundly typed in \\(\\Gamma\\) (read as \\(\\Gamma\\) yields \\(S\\))</li> <li> \\[\\begin{array}{rc}     {\\tt (xsTcCase)} &amp; \\begin{array}{c}         \\begin{array}{cc} C_1 &amp; C_2 \\end{array}         \\\\ \\hline         S_1     \\end{array} \\end{array} \\] <p>is read as \\(C_1 \\land C_2 \\implies S_1\\)</p> </li> </ul>"},{"location":"static/xs_type_chk/#11-well-typed-programs","title":"1.1 Well Typed Programs","text":"<p>An XS program \\(X := \\bar{S}\\) (a sequence of statements) is said to be well typed iff \\(\\exists\\ \\Gamma\\ |\\ \\Gamma \\vdash X\\) (there exists some type environment such that it can type check the program)</p>"},{"location":"static/xs_type_chk/#2-type-checking-for-expressions","title":"2. Type Checking For Expressions","text":""},{"location":"static/xs_type_chk/#21-literals","title":"2.1. Literals","text":"<p>let \\(L\\) denote a literal</p> \\[ \\begin{array}{rc}     {\\tt (xsTcInt)} &amp; \\begin{array}{c}         L\\ \\in \\{x | -999,999,999 \\leq x \\leq 999,999,999 \\land x \\in \\mathbb{Z} \\}         \\\\ \\hline         \\Gamma \\vdash L : {\\tt int}     \\end{array} \\end{array} \\] <p>(XS \\({\\tt int}\\) literals may not be more than 9 digits long. yES)</p> \\[ \\begin{array}{rc}     {\\tt (xsTcStr)} &amp; \\begin{array}{c}         L\\ {\\tt is\\ a\\ \"\\ delimited\\ sequence\\ of\\ characters}         \\\\ \\hline         \\Gamma \\vdash L : {\\tt string}     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsTcFloat)} &amp; \\begin{array}{c}         L\\ \\in \\mathbb{R}         \\\\ \\hline         \\Gamma \\vdash L : {\\tt float}     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsTcBool)} &amp; \\begin{array}{c}         L\\ \\in \\{{\\tt true,\\ false}\\}         \\\\ \\hline         \\Gamma \\vdash L : {\\tt bool}     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsTcVec)} &amp; \\begin{array}{c}         \\begin{array}{cccc}             L\\ |\\ L := {\\tt vector}(x, y, z)             &amp; \\Gamma \\vdash x : {\\tt int}\\ |\\ {\\tt float}             &amp; \\Gamma \\vdash y : {\\tt int}\\ |\\ {\\tt float}             &amp; \\Gamma \\vdash z : {\\tt int}\\ |\\ {\\tt float}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash L : {\\tt vector}     \\end{array} \\end{array} \\] <p>Note: \\(x\\), \\(y\\), and \\(z\\) must also be literals</p>"},{"location":"static/xs_type_chk/#22-identifier","title":"2.2. Identifier","text":"<p>let \\(X\\) be an identifier</p> \\[ \\begin{array}{rc}     {\\tt (xsTcId)} &amp; \\begin{array}{c}         (X, T)\\ \\in \\Gamma         \\\\ \\hline         \\Gamma \\vdash X : T     \\end{array} \\end{array} \\]"},{"location":"static/xs_type_chk/#23-parenthesis","title":"2.3. Parenthesis","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcParen)} &amp; \\begin{array}{c}         \\Gamma \\vdash E : T          \\\\ \\hline         \\Gamma \\vdash (E) : T     \\end{array} \\end{array} \\]"},{"location":"static/xs_type_chk/#24-function-call-expression","title":"2.4. Function Call (Expression)","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcFncExpr)} &amp; \\begin{array}{c}         \\begin{array}{ccc}             \\Gamma \\vdash {\\tt fnName} : (T_1, ..., T_n) \\rightarrow T_r             &amp; \\Gamma \\vdash E_i : T_i\\ |\\ {\\tt void}             &amp; n \\leq 12         \\end{array}         \\\\ \\hline         \\Gamma \\vdash {\\tt fnName(E_1, ..., E_n)} : T_r     \\end{array} \\end{array} \\] <p>Note: XS can have functions of arity \\(\\in [0, 12]\\) but every function must define default values for each parameter, which means it is possible to omit any number of its arguments which are initialised with defaults in that case. Hence the \\({\\tt T_n | void}\\) type for parameters. There is no currying in XS :(</p>"},{"location":"static/xs_type_chk/#25-operations","title":"2.5. Operations","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcArithInt)} &amp; \\begin{array}{c}         \\begin{array}{ccc}             \\Gamma \\vdash E_1 : {\\tt int}             &amp; \\Gamma \\vdash E_2 : {\\tt int}\\ |\\ {\\tt float}             &amp; {\\tt op}\\ \\in \\{{\\tt +,\\ -,\\ *,\\ /,\\ \\%}\\}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash E_1\\ {\\tt op}\\ E_2 : {\\tt int}     \\end{array} \\end{array} \\] <p>(an \\({\\tt int op float}\\) is an \\({\\tt int}\\) in XS... yES.)</p> \\[ \\begin{array}{rc}     {\\tt (xsTcArithFloat)} &amp; \\begin{array}{c}         \\begin{array}{ccc}             \\Gamma \\vdash E_1 : {\\tt float}             &amp; \\Gamma \\vdash E_2 : {\\tt int}\\ |\\ {\\tt float}             &amp; {\\tt op}\\ \\in \\{{\\tt +,\\ -,\\ *,\\ /,\\ \\%}\\}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash E_1\\ {\\tt op}\\ E_2 : {\\tt float}     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsTcStrConc1)} &amp; \\begin{array}{c}         \\begin{array}{cc}             \\Gamma \\vdash E_1 : {\\tt string}             &amp; \\Gamma \\vdash E_2 : {\\tt int}\\ |\\ {\\tt float}\\ |\\ {\\tt bool}\\ |\\ {\\tt string}\\ |\\ {\\tt vector}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash E_1\\ {\\tt +}\\ E_2 : {\\tt string}     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsTcStrConc2)} &amp; \\begin{array}{c}         \\begin{array}{cc}             \\Gamma \\vdash E_1 : {\\tt int}\\ |\\ {\\tt float}\\ |\\ {\\tt bool}\\ |\\ {\\tt string}\\ |\\ {\\tt vector}             &amp; \\Gamma \\vdash E_2 : {\\tt string}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash E_1\\ {\\tt +}\\ E_2 : {\\tt string}     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsTcRelnNum)} &amp; \\begin{array}{c}         \\begin{array}{ccc}             \\Gamma \\vdash E_1 : {\\tt int}\\ |\\ {\\tt float}             &amp; \\Gamma \\vdash E_2 : {\\tt int}\\ |\\ {\\tt float}             &amp; {\\tt op}\\ \\in \\{{\\tt &lt;,\\ &lt;=,\\ &gt;,\\ &gt;=,\\ ==,\\ !=}\\}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash E_1\\ {\\tt op}\\ E_2 : {\\tt bool}     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsTcRelnStr)} &amp; \\begin{array}{c}         \\begin{array}{ccc}             \\Gamma \\vdash E_1 : {\\tt string}             &amp; \\Gamma \\vdash E_2 : {\\tt string}             &amp; {\\tt op}\\ \\in \\{{\\tt &lt;,\\ &lt;=,\\ &gt;,\\ &gt;=,\\ ==,\\ !=}\\}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash E_1\\ {\\tt op}\\ E_2 : {\\tt bool}     \\end{array} \\end{array} \\] <p>Note: strings are compared lexically</p> \\[ \\begin{array}{rc}     {\\tt (xsTcEqVec)} &amp; \\begin{array}{c}         \\begin{array}{ccc}             \\Gamma \\vdash E_1 : {\\tt vector}             &amp; \\Gamma \\vdash E_2 : {\\tt vector}             &amp; {\\tt op}\\ \\in \\{{\\tt ==,\\ !=}\\}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash E_1\\ {\\tt op}\\ E_2 : {\\tt bool}     \\end{array} \\end{array} \\] \\[ \\begin{array}{rc}     {\\tt (xsTcEqBool)} &amp; \\begin{array}{c}         \\begin{array}{ccc}             \\Gamma \\vdash E_1 : {\\tt bool}             &amp; \\Gamma \\vdash E_2 : {\\tt bool}             &amp; {\\tt op}\\ \\in \\{{\\tt ==,\\ !=}\\}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash E_1\\ {\\tt op}\\ E_2 : {\\tt bool}     \\end{array} \\end{array} \\] <p>Note: Trying relational operators on vectors and booleans passes the in game type checker, but will cause a silent XS crash.</p> \\[ \\begin{array}{rc}     {\\tt (xsTcLogical)} &amp; \\begin{array}{c}         \\begin{array}{ccc}             \\Gamma \\vdash E_1 : {\\tt bool}             &amp; \\Gamma \\vdash E_2 : {\\tt bool}             &amp; {\\tt op}\\ \\in \\{{\\tt \\&amp;\\&amp;,\\ ||}\\}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash E_1\\ {\\tt op}\\ E_2 : {\\tt bool}     \\end{array} \\end{array} \\]"},{"location":"static/xs_type_chk/#3-type-checking-for-statements","title":"3. Type Checking For Statements","text":""},{"location":"static/xs_type_chk/#31-sequence","title":"3.1. Sequence","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcSeq)} &amp; \\begin{array}{c}         \\begin{array}{cc}             \\Gamma \\vdash S             &amp; \\Gamma \\vdash \\bar{S}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash S\\bar{S}     \\end{array} \\end{array} \\]"},{"location":"static/xs_type_chk/#32-include","title":"3.2. Include","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcInc)} &amp; \\begin{array}{c}         \\Gamma \\vdash S : {\\tt string}         \\\\ \\hline         \\Gamma \\vdash {\\tt include\\ }S{\\tt;}     \\end{array} \\end{array} \\]"},{"location":"static/xs_type_chk/#33-var-def","title":"3.3. Var Def","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcDef)} &amp; \\begin{array}{c}         \\Gamma \\vdash E : T         \\\\ \\hline         \\begin{array}{cc}             \\Gamma \\vdash T\\ X\\ =\\ E{\\tt ;}             &amp; \\Gamma \\oplus (X, T)         \\end{array}     \\end{array} \\end{array} \\] <p>Note an initialiser in a definition is optional</p>"},{"location":"static/xs_type_chk/#34-var-assign","title":"3.4. Var Assign","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcAssign)} &amp; \\begin{array}{c}         \\begin{array}{cc}             \\Gamma \\vdash X : T             &amp; \\Gamma \\vdash E : T         \\end{array}         \\\\ \\hline         \\Gamma \\vdash X\\ =\\ E{\\tt ;}     \\end{array} \\end{array} \\] <p>Note: floats may be assigned to ints - they follow the expected casting rules.</p>"},{"location":"static/xs_type_chk/#35-if-else","title":"3.5. If Else","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcIfElse)} &amp; \\begin{array}{c}         \\begin{array}{ccc}             \\Gamma \\vdash E_c : {\\tt bool}             &amp; \\Gamma \\vdash \\bar{S_1}             &amp; \\Gamma \\vdash \\bar{S_2}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash {\\tt if\\ (} E_c {\\tt)\\ \\{\\ } \\bar{S_1} {\\tt\\ \\}\\ else\\ \\{\\ } \\bar{S_2} {\\tt\\ \\}}     \\end{array} \\end{array} \\]"},{"location":"static/xs_type_chk/#36-while","title":"3.6. While","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcWhile)} &amp; \\begin{array}{c}         \\begin{array}{cc}             \\Gamma \\vdash E_c : {\\tt bool}             &amp; \\Gamma \\vdash \\bar{S}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash {\\tt while\\ (} E_c {\\tt)\\ \\{\\ } \\bar{S} {\\tt\\ \\}}     \\end{array} \\end{array} \\]"},{"location":"static/xs_type_chk/#37-for","title":"3.7. For","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcFor)} &amp; \\begin{array}{c}         \\begin{array}{cccc}             \\Gamma \\vdash E_1 : {\\tt int}\\ |\\ {\\tt float}\\ |\\ {\\tt bool}             &amp; \\Gamma \\vdash E_2 : {\\tt int}\\ |\\ {\\tt float}             &amp; \\Gamma \\vdash \\bar{S}             &amp; \\text{OP } \\in {\\{\\tt &lt;,\\ &lt;=,\\ &gt;,\\ &gt;=}\\}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash {\\tt for\\ (}X\\ =\\ E_1{\\tt ;}\\ {\\tt op}\\ E_2 {\\tt)\\ \\{\\ } \\bar{S} {\\tt\\ \\}}     \\end{array} \\end{array} \\] <p>Note: Floats may be used in \\(E_1\\) or \\(E_2\\) they will be cast to int before being used by the loop. Bools in the initializer are cast to int, bools in the conditional pass the in game type checker but will cause a silent XS crash.</p>"},{"location":"static/xs_type_chk/#38-switch","title":"3.8. Switch","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcSwitch)} &amp; \\begin{array}{c}         \\begin{array}{cccc}             \\Gamma \\vdash E_c : {\\tt int}\\ |\\ {\\tt float}\\ |\\ {\\tt bool}             &amp; \\Gamma \\vdash E_i : {\\tt int}\\ |\\ {\\tt float}             &amp; \\Gamma \\vdash \\bar{S_i}             &amp; \\Gamma \\vdash \\bar{S_d}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash {\\tt switch\\ (} E_c {\\tt)\\ \\{\\ } {\\tt case\\ } E_1 {\\tt\\ :\\ \\{\\ } \\bar{S_1} {\\tt\\ \\}} {\\tt\\ ...\\ case\\ } E_n {\\tt\\ :\\ \\{\\ } \\bar{S_n} {\\tt\\ \\}} {\\tt\\ default\\ :\\ \\{\\ } \\bar{S_d} {\\tt\\ \\}} {\\tt\\ \\}}     \\end{array} \\end{array} \\] <p>Note: Floats may be used in \\(E_c\\) or \\(E_n\\) they will be cast to int before being used by the cases. Bools in the expression are cast to int, bools in a case's expression pass the in game type checker but will cause a silent XS crash.</p>"},{"location":"static/xs_type_chk/#39-break-continue-break-point-debug","title":"3.9. Break, Continue, Break Point, Debug","text":"\\[\\begin{matrix} {\\tt (xsTcBr)} &amp; \\Gamma \\vdash {\\tt break;} \\end{matrix}\\] \\[\\begin{matrix} {\\tt (xsTcCo)} &amp; \\Gamma \\vdash {\\tt continue;} \\end{matrix}\\] \\[\\begin{matrix} {\\tt (xsTcBrPt)} &amp; \\Gamma \\vdash {\\tt breakpoint;} \\end{matrix}\\] \\[ \\begin{array}{rc}     {\\tt (xsTcDbg)} &amp; \\begin{array}{c}         \\begin{array}{c}             \\Gamma \\vdash X : T             &amp; T \\notin \\{A \\rightarrow B, {\\tt rule}, {\\tt label}, {\\tt class}\\}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash {\\tt dbg\\ } X{\\tt ;}     \\end{array} \\end{array} \\]"},{"location":"static/xs_type_chk/#310-function-definitions","title":"3.10. Function Definitions","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcFn)} &amp; \\begin{array}{c}         \\begin{array}{cccccc}             T_r \\in \\{{\\tt int,\\ float,\\ bool,\\ string,\\ vector,\\ void}\\}             &amp; \\Gamma \\vdash E_i : T_i             &amp; n \\leq 12             &amp; \\Gamma \\vdash \\bar{S}             &amp; {\\tt return\\ E_r;} \\in \\bar{S}             &amp; \\Gamma \\vdash E_r : T_r         \\end{array}         \\\\ \\hline         \\begin{array}{cc}             \\Gamma \\vdash T_r\\ {\\tt fnName(T_1\\ id_1\\ =\\ E_1,\\ ...,\\ T_n\\ id_n\\ =\\ E_n )\\ \\{\\ } \\bar{S} {\\tt\\ \\}}             &amp; \\Gamma \\oplus ({\\tt fnName}, (T_1, ..., T_n) \\rightarrow T_r)         \\end{array}     \\end{array} \\end{array} \\] <p>If the return type of a function is \\({\\tt void}\\), the return statement may be omitted</p>"},{"location":"static/xs_type_chk/#311-rule-definitions","title":"3.11. Rule Definitions","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcRule)} &amp; \\begin{array}{c}         \\Gamma \\vdash \\bar{S}         \\\\ \\hline         \\begin{array}{cc}             \\Gamma \\vdash {\\tt rule\\ ruleName\\ ruleOpts\\ \\ \\{\\ } \\bar{S} {\\tt\\ \\}}             &amp; \\Gamma \\oplus ({\\tt ruleName}, {\\tt rule})         \\end{array}     \\end{array} \\end{array} \\]"},{"location":"static/xs_type_chk/#312-postfix","title":"3.12. Postfix","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcPost)} &amp; \\begin{array}{c}         \\begin{array}{cc}             ({\\tt id,\\ int\\ |\\ float}) \\in \\Gamma             &amp; \\text{##}\\ \\in \\{{\\tt ++,\\ --}\\}         \\end{array}         \\\\ \\hline         \\Gamma \\vdash \\text{id##;}     \\end{array} \\end{array} \\] <p>Postfixes are expressions statements in XS. yES</p>"},{"location":"static/xs_type_chk/#313-label-goto","title":"3.13. Label, Goto","text":"\\[\\begin{matrix} {\\tt (xsTcLabel)} &amp; \\Gamma \\vdash {\\tt label\\ id;} \\end{matrix}\\] \\[\\begin{matrix} {\\tt (xsTcGoto)} &amp; \\Gamma \\vdash {\\tt goto\\ id;} \\end{matrix}\\]"},{"location":"static/xs_type_chk/#314-function-call-statement","title":"3.14. Function Call (Statement)","text":"<p>\\(({\\tt xsTcFncStmt})\\) same as 2.4. Function Call (Expression) with a terminating semicolon.</p>"},{"location":"static/xs_type_chk/#315-class-definition","title":"3.15. Class Definition","text":"\\[ \\begin{array}{rc}     {\\tt (xsTcClsDef)} &amp; \\begin{array}{c}         \\begin{array}{c}             \\Gamma \\vdash E_i : T_i         \\end{array}         \\\\ \\hline         \\Gamma \\vdash {\\tt class\\ clsName\\ \\{}\\ T_1\\ id_1\\ =\\ E_1;\\ ...\\ T_n\\ id_n\\ =\\ E_n; {\\tt\\ \\};}     \\end{array} \\end{array} \\] <p>Classes are unused in XS and can't be instantiated afaik. This exists purely for completeness' sake.</p>"},{"location":"static/xs_type_inf/","title":"XS Type Inference","text":"<p>There is no type inference for identifiers in XS, as the syntax is like C/C++ without the \\({\\tt auto}\\) keyword.</p>"},{"location":"xs_vm/xs_rt/","title":"XS VM Runtime Environment","text":"<p>A description of the XS VM state</p>"}]}